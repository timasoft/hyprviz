## Основы

```ini
bind = МОДИФИКАТОРЫ, клавиша, диспетчер, параметры
```

например,

```ini
bind = SUPER_SHIFT, Q, exec, firefox
```

привяжет открытие Firefox к комбинации <key>SUPER</key> + <key>SHIFT</key> + <key>Q</key>

{{< callout type=info >}}

Для привязки клавиш без модификатора оставьте его пустым:

```ini
bind = , Print, exec, grim
```

{{< /callout >}}

_Полный список модификаторов см. в разделе [Переменные](../Variables/#variable-types)._

_Список диспетчеров можно найти в разделе [Диспетчеры](../Dispatchers/#list-of-dispatchers)._

## Необычные символы / привязка по коду клавиши

См. заголовочный файл [xkbcommon-keysyms.h](https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-keysyms.h) для всех доступных символов. Имя, которое следует использовать, это часть после `XKB_KEY_`.

Если вы хотите привязать по коду клавиши, вы можете поместить его в позицию KEY с префиксом `code:`, например:

```ini
bind = SUPER, code:28, exec, amongus
```

Это привяжет <key>SUPER</key> + <key>t</key>, так как <key>t</key> имеет код клавиши 28.

{{< callout type=info >}}

Если вы не уверены в имени или коде вашей клавиши, вы можете использовать [`wev`](https://github.com/jwrdegoede/wev), чтобы узнать.

{{< /callout >}}

## Разное

### Привязки рабочих пространств в раскладках, отличных от QWERTY

Клавиши, используемые для привязок, должны быть доступны без каких-либо модификаторов в вашей раскладке.  
Например, французская раскладка [AZERTY](https://en.wikipedia.org/wiki/AZERTY) использует <key>SHIFT</key> + _`неподправленная клавиша`_ для ввода цифр `0-9`. Таким образом, привязки рабочих пространств для этой раскладки должны использовать имена _`неподправленных клавиш`_, и не будут работать при использовании цифр `0-9`.

{{< callout type=info >}}

Чтобы получить правильное имя для `неподправленной_клавиши`, обратитесь к [разделу о необычных символах](#необычные-символы--привязка-по-коду-клавиши)

{{< /callout >}}

```ini
# Для французской раскладки вместо:
# bind = $mainMod, 1, workspace,  1

# Используйте
bind = $mainMod, ampersand, workspace,  1
```

Для помощи в настройке французской раскладки AZERTY см. эту [статью](https://rherault.dev/articles/hyprland-fr-layout).

### Отвязка

Вы также можете отвязать клавишу с помощью ключевого слова `unbind`, например:

```ini
unbind = SUPER, O
```

Это может быть полезно для динамических привязок с помощью `hyprctl`, например:

```bash
hyprctl keyword unbind SUPER, O
```

{{< callout type=info >}}
В `unbind` имя клавиши чувствительно к регистру. Оно должно точно соответствовать регистру привязки, которую вы отвязываете.

```ini
bind = SUPER, TAB, workspace, e+1
unbind = SUPER, Tab # это НЕ отвяжет
unbind = SUPER, TAB # это отвяжет
```

{{< /callout >}}

## Флаги привязок

`bind` поддерживает флаги в следующем формате:

```ini
bind[флаги] = ...
```

например:

```ini
bindrl = MOD, KEY, exec, amongus
```

Доступные флаги:

| Флаг | Название | Описание |
|------|----------|----------|
| `l` | locked | Будет работать даже при активном ингибиторе ввода (например, экране блокировки). |
| `r` | release | Будет срабатывать при отпускании клавиши. |
| `c` | click | Будет срабатывать при отпускании клавиши или кнопки мыши, если курсор мыши остался внутри `binds:drag_threshold`. |
| `g` | drag | Будет срабатывать при отпускании клавиши или кнопки мыши, если курсор мыши вышел за пределы `binds:drag_threshold`. |
| `o` | long press | Будет срабатывать при долгом нажатии клавиши. |
| `e` | repeat | Будет повторяться при удержании. |
| `n` | non-consuming | События клавиатуры/мыши будут передаваться активному окну в дополнение к срабатыванию диспетчера. |
| `m` | mouse | См. специальный раздел [Привязки мыши](#привязки-мыши). |
| `t` | transparent | Не может быть перекрыт другими привязками. |
| `i` | ignore mods | Будет игнорировать модификаторы. |
| `s` | separate | Будет произвольно комбинировать клавиши между каждым модификатором/клавишей, см. [Комбинации keysym](#комбинации-keysym). |
| `d` | has description | Позволит написать описание для вашей привязки. |
| `p` | bypass | Обходит запросы приложения на блокировку привязок. |

Примеры использования:

```ini
# Пример кнопки громкости, которая позволяет нажимать и удерживать, ограничение громкости до 150%
binde = , XF86AudioRaiseVolume, exec, wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 5%+

# Пример кнопки громкости, которая будет активироваться даже при активном ингибиторе ввода
bindl = , XF86AudioLowerVolume, exec, wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%-

# Открывает wofi при первом нажатии, закрывает его при втором
bindr = SUPER, SUPER_L, exec, pkill wofi || wofi

# Описать привязку
bindd = SUPER, Q, Открыть мой любимый терминал, exec, kitty

# Пропустить трек при долгом нажатии и только на 5 секунд при обычном нажатии
bindo = SUPER, XF86AudioNext, exec, playerctl next
bind = SUPER, XF86AudioNext, exec, playerctl position +5
```

### Кнопки мыши

Вы также можете привязать или отвязать кнопки мыши, добавив префикс `mouse:` к коду кнопки мыши, например:

```ini
bind = SUPER, mouse:272, exec, amongus  # привязывает `exec amogus` к SUPER + ЛКМ.
```

### Привязка только модификаторов

Чтобы привязать только модификаторы, вам нужно использовать TARGET modmask (с активирующим модификатором) и флаг `r`, например:

```ini
bindr = SUPER ALT, Alt_L, exec, amongus  # привязывает `exec amongus` к SUPER + ALT.
```

### Комбинации keysym

Для произвольной комбинации нескольких клавиш разделите keysym символом `&` между каждым модификатором/клавишей и используйте флаг `s`, например:

```ini
# Вы можете использовать один модификатор с несколькими клавишами.
binds = Control_L, A&Z, exec, kitty
# Вы также можете указать несколько конкретных модификаторов.
binds = Control_L&Shift_L, K, exec, kitty
# Вы также можете сделать и то, и другое!
binds = Control_R&Super_R&Alt_L, J&K&L, exec, kitty
# Если вы чувствуете себя немного безумно... вы можете использовать другие клавиши для привязок...
binds = Escape&Apostrophe&F7, T&O&A&D, exec, battletoads 2: retoaded
```

{{< callout type=info >}}

Обратите внимание, что это действительно только для keysym, и все модификаторы становятся keysym.  
Если вы не знаете, что такое keysym, используйте `wev` и нажмите клавишу, которую хотите использовать.

{{< /callout >}}

### Колесо мыши

Вы также можете привязать события колеса мыши с помощью `mouse_up` и `mouse_down` (или `mouse_left` и `mouse_right`, если ваша мышь поддерживает горизонтальную прокрутку):

```ini
bind = SUPER, mouse_down, workspace, e-1
```

{{< callout type=info >}}

Вы можете контролировать время сброса с помощью `binds:scroll_event_delay`.

{{< /callout >}}

### Переключатели

Переключатели полезны для привязки событий, таких как закрытие и открытие крышки ноутбука:

```ini
# Срабатывает при переключении переключателя.
bindl = , switch:[имя_переключателя], exec, swaylock
# Срабатывает при включении переключателя.
bindl = , switch:on:[имя_переключателя], exec, hyprctl keyword monitor "eDP-1, disable"
# Срабатывает при выключении переключателя.
bindl = , switch:off:[имя_переключателя], exec, hyprctl keyword monitor "eDP-1, 2560x1600, 0x0, 1"
```

{{< callout type=warning >}}

Настройки Systemd `HandleLidSwitch` в `logind.conf` могут конфликтовать с конфигурацией переключателя крышки ноутбука в Hyprland.

{{< /callout >}}

{{< callout type=info >}}

Вы можете просмотреть свои переключатели с помощью `hyprctl devices`.

{{< /callout >}}

### Несколько привязок к одной клавише

Вы можете запускать несколько действий с помощью одной и той же привязки клавиш, назначив ее несколько раз с разными `диспетчерами` и `параметрами`:

```ini
# Для переключения между окнами в плавающем рабочем пространстве:
bind = SUPER, Tab, cyclenext         # Изменить фокус на другое окно
bind = SUPER, Tab, bringactivetotop  # Переместить его наверх
```

{{< callout type=warning >}}

Привязки клавиш будут выполняться сверху вниз, в порядке их написания.

{{< /callout >}}

### Описание

Вы можете описать свою привязку клавиш с помощью флага `d`.  
Ваше описание всегда идет перед `диспетчером` и не должно содержать запятых (`,`)!

```ini
bindd = МОДИФИКАТОРЫ, клавиша, описание, диспетчер, параметры
```

Например:

```ini
bindd = SUPER, Q, Открыть мой любимый терминал, exec, kitty
```

Если вы хотите получить доступ к своему описанию, вы можете использовать `hyprctl binds`.  
Для получения дополнительной информации ознакомьтесь с разделом [Использование Hyprctl](../Using-hyprctl).

## Привязки мыши

Это привязки, которые зависят от движения мыши. У них будет на один аргумент меньше.  
`binds:drag_threshold` можно использовать для различения между кликами и перетаскиванием с одной и той же кнопкой:

```ini
binds {
    drag_threshold = 10  # Запускать событие перетаскивания только после перетаскивания более чем на 10px
}
bindm = ALT, mouse:272, movewindow      # ALT + ЛКМ: Перемещение окна перетаскиванием более чем на 10px.
bindc = ALT, mouse:272, togglefloating  # ALT + ЛКМ: Плавающий режим окна при клике
```

Доступные привязки мыши:

| Название | Описание | Параметры |
| -------- | -------- | --------- |
| movewindow | перемещает активное окно | Нет |
| resizewindow | изменяет размер активного окна | `1` -> Изменение размера с сохранением соотношения сторон окна. <br> `2` -> Изменение размера и игнорирование правила/свойства окна `keepaspectratio`. <br> Нет или что-либо еще для обычного изменения размера |

Распространенные коды кнопок мыши (проверьте `wev` для других кнопок):

```txt
ЛКМ -> 272
ПКМ -> 273
СКМ -> 274
```

{{< callout type=info >}}

Привязки мыши, несмотря на свое название, ведут себя как обычные привязки.  
Вы можете свободно использовать любые клавиши / модификаторы по своему усмотрению. При удержании будет активирована функция мыши.

{{< /callout >}}

### Тачпад

Поскольку клик и перемещение мыши на тачпаде неудобны, вы также можете использовать клавиши клавиатуры вместо кликов мыши.

```ini
bindm = SUPER, mouse:272, movewindow
bindm = SUPER, Control_L, movewindow
bindm = SUPER, mouse:273, resizewindow
bindm = SUPER, ALT_L, resizewindow
```

## Глобальные привязки клавиш

### Классические

Да, вы правильно услышали, Hyprland поддерживает глобальные привязки клавиш для _ВСЕХ_ приложений, включая OBS, Discord, Firefox и т.д.

См. диспетчеры [`pass`](../Dispatchers/#list-of-dispatchers) и [`sendshortcut`](../Dispatchers/#list-of-dispatchers) для привязок клавиш.

Возьмем OBS в качестве примера: привязка "Start/Stop Recording" установлена на <key>SUPER</key> + <key>F10</key>, чтобы сделать ее работающей глобально, просто добавьте:

```ini
bind = SUPER, F10, pass, class:^(com.obsproject.Studio)$
```

в ваш конфиг и все готово.

`pass` будет передавать события `PRESS` и `RELEASE` сам по себе, нет необходимости в `bindr`.  
Это также означает, что push-to-talk будет работать безупречно с одним `pass`, например:

```ini
bind = , mouse:276, pass, class:^(TeamSpeak 3)$  # Передает MOUSE5 в TeamSpeak3.
```

Вы также можете добавлять сочетания клавиш, где другие клавиши передаются окну.

```ini
bind = SUPER, F10, sendshortcut, SUPER, F4, class:^(com.obsproject.Studio)$  # Отправляет SUPER + F4 в OBS при нажатии SUPER + F10.
```

{{< callout type=warning >}}

Это работает безупречно со всеми нативными Wayland-приложениями, однако XWayland немного капризничает.  
Убедитесь, что то, что вы передаете, является "глобальной Xorg-привязкой", иначе передача из другого XWayland-приложения может не работать.

{{< /callout >}}

### Глобальные сочетания клавиш через DBus

Некоторые приложения могут уже поддерживать портал GlobalShortcuts в xdg-desktop-portal.  
Если это так, рекомендуется использовать следующий метод вместо `pass`:

Откройте нужное вам приложение и запустите `hyprctl globalshortcuts` в терминале.  
Это даст вам список зарегистрированных в данный момент сочетаний клавиш с их описаниями.

Выберите любое, например `coolApp:myToggle`, и привяжите его к чему угодно с помощью диспетчера `global`:

```ini
bind = SUPERSHIFT, A, global, coolApp:myToggle
```

{{< callout type=info >}}

Обратите внимание, что эта функция будет _только_ работать с [XDPH](../../Hypr-Ecosystem/xdg-desktop-portal-hyprland).

{{</ callout >}}

## Подкарты

Подкарты привязок клавиш, также известные как _режимы_ или _группы_, позволяют активировать отдельный набор привязок клавиш.  
Например, если вы хотите войти в _режим_ `resize`, который позволяет изменять размер окон стрелками, вы можете сделать это так:

```ini
# Переключиться на подкарту с именем `resize`.
bind = ALT, R, submap, resize

# Начать подкарту с именем "resize".
submap = resize

# Установить повторяемые привязки для изменения размера активного окна.
binde = , right, resizeactive, 10 0
binde = , left, resizeactive, -10 0
binde = , up, resizeactive, 0 -10
binde = , down, resizeactive, 0 10

# Используйте `reset` для возврата к глобальной подкарте
bind = , escape, submap, reset

# Сбросить подкарту, что вернет вас к глобальной подкарте
submap = reset

# Дальнейшие привязки будут глобальными...
```

{{< callout type=warning >}}

Не забудьте привязку клавиши (`escape`, в данном случае) для сброса карты клавиш при нахождении внутри нее!

Если вы застряли внутри карты клавиш, вы можете использовать `hyprctl dispatch submap reset`, чтобы вернуться.  
Если у вас нет открытого терминала, вам не повезло. Вас предупреждали.

{{< /callout >}}

Вы также можете установить одну и ту же привязку клавиши для выполнения нескольких действий, таких как изменение размера и закрытие подкарты, следующим образом:

```ini
bind = ALT, R, submap, resize

submap = resize

bind = , right, resizeactive, 10 0
bind = , right, submap, reset
# ...

submap = reset
```

Это работает, потому что привязки выполняются в порядке их появления, и присвоение нескольких действий одной привязке возможно.

### Вложенность

Подкарты могут быть вложенными, см. следующий пример:

```ini
bind = $mainMod, M, submap, main_submap
submap = main_submap

# ...

# nested_one
bind = , 1, submap, nested_one
submap = nested_one

# ...

bind = SHIFT, escape, submap, reset
bind =      , escape, submap, main_submap
submap = main_submap
# /nested_one

# nested_two
bind = , 2, submap, nested_two
submap = nested_two

# ...

bind = SHIFT, escape, submap, reset
bind =      , escape, submap, main_submap
submap = main_submap
# /nested_two

bind = , escape, submap, reset
submap = reset
```

### Автоматическое закрытие подкарты после диспетчеризации

Подкарты могут быть автоматически закрыты или переключены на другую подкарту путем добавления ``,`` за которой следует имя подкарты или _reset_.

```ini
bind = SUPER,a, submap, submapA

# Устанавливает подкарту в submapB после нажатия a.
submap = submapA, submapB
bind = ,a,exec, someCoolThing.sh
submap = reset

# Сбрасывает подкарту в значение по умолчанию после нажатия a.
submap = submapB, reset
bind = ,a,exec, someOtherCoolThing.sh
submap = reset
```

### Общая привязка

Вы также можете определить привязку клавиши с помощью специального ключевого слова `catchall`, которая активируется независимо от нажатой клавиши.  
Это можно использовать для предотвращения передачи любых клавиш активному приложению во время нахождения в подкарте или для немедленного выхода из нее при нажатии любой неизвестной клавиши:

```ini
bind = , catchall, submap, reset
```

## Примеры привязок

### Мультимедиа

Эти привязки устанавливают ожидаемое поведение для обычных клавиш регулировки громкости клавиатуры, включая когда экран заблокирован:

```ini
bindel = , XF86AudioRaiseVolume, exec, wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%+
bindel = , XF86AudioLowerVolume, exec, wpctl set-volume @DEFAULT_AUDIO_SINK@ 5%-
bindl = , XF86AudioMute, exec, wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle
# Требуется playerctl
bindl = , XF86AudioPlay, exec, playerctl play-pause
bindl = , XF86AudioPrev, exec, playerctl previous
bindl = , XF86AudioNext, exec, playerctl next
```
